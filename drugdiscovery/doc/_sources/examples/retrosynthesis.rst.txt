Retrosynthesis
==============

.. include:: ../bibliography.rst

Retrosynthesis is a fundamental task in drug discovery. Given a target molecule,
the goal of retrosynthesis is to identify a set of reactants that can produce
the target.

In this example, we will show how to predict retrosynthesis using `G2Gs`_ framework.
`G2Gs`_ first identifies the reaction centers, i.e., bonds generated in the
product. Based on the reaction centers, the product is broken into several
synthons and each synthon is translated to a reactant.

Prepare the Dataset
-------------------

We use the standard `USPTO50k`_ dataset. This dataset contains 50k molecules and
their synthesis pathways.

First, let's download and load the dataset. This may take a while.

There are two modes to load the dataset. The reaction mode loads the dataset as
`(reactant, product)` pairs, which is used for center identification. The synthon
mode loads the dataset as `(reactant, synthon)` pairs, which is used for synthon
completion.

.. code:: python

    from drugdiscovery import datasets

    reaction_dataset = datasets.USPTO50k("~/molecule-datasets/",
                                         node_feature="reaction_center_identification",
                                         kekulize=True)
    synthon_dataset = datasets.USPTO50k("~/molecule-dataset/", as_synthon=True,
                                        node_feature="reaction_center_identification"
                                        kekulize=True)

Then we visualize some samples from the dataset. For the reaction dataset, we can
split reactant and product graphs into individual molecules using
:meth:`connected_components() <drugdiscovery.data.Graph.connected_components>`.
Note `USPTO50k`_ ignores all non-target products, so there is only one product on
the right hand side.

.. code:: python

    from drugdiscovery.utils import plot

    for i in range(2):
        sample = reaction_dataset[i]
        reactant, product = sample["graph"]
        reactants = reactant.connected_components()[0]
        products = product.connected_components()[0]
        plot.reaction(reactants, products)

.. image:: ../../../asset/dataset/uspto50k_0.png
    :width: 49%
.. image:: ../../../asset/dataset/uspto50k_1.png
    :width: 49%

Here are the corresponding samples in the synthon dataset.

.. code:: python

    for i in range(3):
        sample = synthon_dataset[i]
        reactant, synthon = sample["graph"]
        plot.reaction([reactant], [synthon])

.. image:: ../../../asset/dataset/uspto50k_synthon_0.png
    :width: 49%
.. image:: ../../../asset/dataset/uspto50k_synthon_1.png
    :width: 24%
.. image:: ../../../asset/dataset/uspto50k_synthon_2.png
    :width: 24%

To ensure the same split is used by both datasets, we can set the random seed
before calling :meth:`split() <drugdiscovery.datasets.USPTO50k.split>`.

.. code::

    torch.manual_seed(1)
    reaction_train, reaction_valid, reaction_test = reaction_dataset.split()
    synthon_train, synthon_valid, synthon_test = synthon_dataset.split()

Center Identification
---------------------

Now we define our model. We use a Relational Graph Convolutional Network (RGCN)
as our representation model, and wrap it for the center identification task. Note
other graph representation learning models can also be used here.

.. code:: python

    from drugdiscovery import core, models, tasks

    model = models.RGCN(input_dim=dataset.node_feature_dim,
                        hidden_dims=[256, 256, 256, 256],
                        num_relation=dataset.num_bond_type,
                        short_cut=True)
    task = tasks.CenterIdentification(model, feature=("graph", "atom", "bond"))

.. code:: python

    optimizer = torch.optim.Adam(task.parameters(), lr=1e-3)
    solver = core.Engine(task, reaction_train, reaction_valid, reaction_test, optimizer,
                         gpus=[0], batch_size=128)
    solver.train(num_epoch=10)
    solver.evaluate("valid")

The evaluation result on the validation set may look like

.. code:: bash

    accuracy: 0.795255

We can show some predictions from our model. For diversity, we collect samples
from 4 different reaction types.

.. code:: python

    batch = []
    reaction_set = set()
    for sample in valid_set:
        if sample["reaction"] not in reaction_set:
            batch.append(sample)
            reaction_set.add(sample["reaction"])
            if len(batch) == 4:
                break
    batch = data.graph_collate(batch)
    batch = utils.cuda(batch)
    result = task.predict_synthon(batch)

The following code visualizes the ground truths as well as our predictions on the
samples. We use blue for ground truths, red for wrong predictions, and purple for
correct predictions.

.. code:: python

    def atoms_and_bonds(molecule, reaction_center):
        is_reaction_atom = (molecule.atom_map > 0) & \
                           (molecule.atom_map.unsqueeze(-1) == reaction_center.unsqueeze(0)).any(dim=-1)
        node_in, node_out = molecule.edge_list.t()[:2]
        edge_map = molecule.atom_map[molecule.edge_list[:, :2]]
        is_reaction_bond = (edge_map > 0).all(dim=-1) & \
                           (edge_map == reaction_center.unsqueeze(0)).all(dim=-1)
        atoms = is_reaction_atom.nonzero().flatten().tolist()
        bonds = is_reaction_bond[node_in < node_out].nonzero().flatten().tolist()
        return atoms, bonds

    products = batch["graph"][1]
    reaction_centers = result["reaction_center"][0]

    for i, product in enumerate(products):
        true_atoms, true_bonds = atoms_and_bonds(product, product.reaction_center)
        true_atoms, true_bonds = set(true_atoms), set(true_bonds)
        pred_atoms, pred_bonds = atoms_and_bonds(product, reaction_centers[i])
        pred_atoms, pred_bonds = set(pred_atoms), set(pred_bonds)
        overlap_atoms = true_atoms.intersection(pred_atoms)
        overlap_bonds = true_bonds.intersection(pred_bonds)
        atoms = true_atoms.union(pred_atoms)
        bonds = true_bonds.union(pred_bonds)

        red = (1, 0.5, 0.5)
        blue = (0.5, 0.5, 1)
        purple = (1, 0.5, 1)
        atom_colors = {}
        bond_colors = {}
        for atom in atoms:
            if atom in overlap_atoms:
                atom_colors[atom] = purple
            elif atom in pred_atoms:
                atom_colors[atom] = red
            else:
                atom_colors[atom] = blue
        for bond in bonds:
            if bond in overlap_bonds:
                bond_colors[bond] = purple
            elif bond in pred_bonds:
                bond_colors[bond] = red
            else:
                bond_colors[bond] = blue

        plot.highlight(product, atoms, bonds, atom_colors, bond_colors)

.. image:: ../../../asset/dataset/uspto50k_center_valid_0.png
    :width: 24%
.. image:: ../../../asset/dataset/uspto50k_center_valid_1.png
    :width: 24%
.. image:: ../../../asset/dataset/uspto50k_center_valid_2.png
    :width: 24%
.. image:: ../../../asset/dataset/uspto50k_center_valid_3.png
    :width: 24%

Synthon Completion
------------------

Retrosynthesis
--------------