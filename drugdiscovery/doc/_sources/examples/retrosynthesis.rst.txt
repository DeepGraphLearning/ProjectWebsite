Retrosynthesis
==============

.. include:: ../bibliography.rst

Retrosynthesis is a fundamental task in drug discovery. Given a target molecule,
the goal of retrosynthesis is to identify a set of reactants that can produce
the target.

In this example, we will show how to predict retrosynthesis using `G2Gs`_ framework.
`G2Gs`_ first identifies the reaction centers, i.e., bonds generated in the
product. Based on the reaction centers, the product is broken into several
synthons and each synthon is translated to a reactant.

Prepare the Dataset
-------------------

We use the standard `USPTO50k`_ dataset. This dataset contains 50k molecules and
their synthesis pathways.

First, let's download and load the dataset. This may take a while.

There are two modes to load the dataset. The reaction mode loads the dataset as
`(reactant, product)` pairs, which is used for center identification. The synthon
mode loads the dataset as `(reactant, synthon)` pairs, which is used for synthon
completion.

.. code:: python

    from drugdiscovery import datasets

    reaction_dataset = datasets.USPTO50k("~/molecule-datasets/",
                                         node_feature="reaction_reaction_identification",
                                         kekulize=True)
    synthon_dataset = datasets.USPTO50k("~/molecule-dataset/", as_synthon=True,
                                        node_feature="synthon_completion",
                                        kekulize=True)

Then we visualize some samples from the dataset. For the reaction dataset, we can
split reactant and product graphs into individual molecules using
:meth:`connected_components() <drugdiscovery.data.Graph.connected_components>`.
Note `USPTO50k`_ ignores all non-target products, so there is only one product on
the right hand side.

.. code:: python

    from drugdiscovery.utils import plot

    for i in range(2):
        sample = reaction_dataset[i]
        reactant, product = sample["graph"]
        reactants = reactant.connected_components()[0]
        products = product.connected_components()[0]
        plot.reaction(reactants, products)

.. image:: ../../../asset/dataset/uspto50k_0.png
    :width: 49%
.. image:: ../../../asset/dataset/uspto50k_1.png
    :width: 49%

Here are the corresponding samples in the synthon dataset.

.. code:: python

    for i in range(3):
        sample = synthon_dataset[i]
        reactant, synthon = sample["graph"]
        plot.reaction([reactant], [synthon])

.. image:: ../../../asset/dataset/uspto50k_synthon_0.png
    :width: 49%
.. image:: ../../../asset/dataset/uspto50k_synthon_1.png
    :width: 24%
.. image:: ../../../asset/dataset/uspto50k_synthon_2.png
    :width: 24%

To ensure the same split is used by both datasets, we can set the random seed
before calling :meth:`split() <drugdiscovery.datasets.USPTO50k.split>`.

.. code::

    torch.manual_seed(1)
    reaction_train, reaction_valid, reaction_test = reaction_dataset.split()
    synthon_train, synthon_valid, synthon_test = synthon_dataset.split()

Center Identification
---------------------

Now we define our model. We use a Relational Graph Convolutional Network (RGCN)
as our representation model, and wrap it for the center identification task. Note
other graph representation learning models can also be used here.

.. code:: python

    from drugdiscovery import core, models, tasks

    reaction_model = models.RGCN(input_dim=dataset.node_feature_dim,
                        hidden_dims=[256, 256, 256, 256],
                        num_relation=dataset.num_bond_type,
                        short_cut=True)
    reaction_task = tasks.CenterIdentification(model, feature=("graph", "atom", "bond"))

.. code:: python

    reaction_optimizer = torch.optim.Adam(reaction_task.parameters(), lr=1e-3)
    reaction_solver = core.Engine(reaction_task, reaction_train, reaction_valid, reaction_test, optimizer,
                         gpus=[0], batch_size=128)
    reaction_solver.train(num_epoch=10)
    reaction_solver.evaluate("valid")

The evaluation result on the validation set may look like

.. code:: bash

    accuracy: 0.795255

We can show some predictions from our model. For diversity, we collect samples
from 4 different reaction types.

.. code:: python

    batch = []
    reaction_set = set()
    for sample in reaction_valid:
        if sample["reaction"] not in reaction_set:
            reaction_set.add(sample["reaction"])
            batch.append(sample)
            if len(batch) == 4:
                break
    batch = data.graph_collate(batch)
    batch = utils.cuda(batch)
    result = reaction_task.predict_synthon(batch)

The following code visualizes the ground truths as well as our predictions on the
samples. We use blue for ground truths, red for wrong predictions, and purple for
correct predictions.

.. code:: python

    def atoms_and_bonds(molecule, reaction_center):
        is_reaction_atom = (molecule.atom_map > 0) & \
                           (molecule.atom_map.unsqueeze(-1) == reaction_center.unsqueeze(0)).any(dim=-1)
        node_in, node_out = molecule.edge_list.t()[:2]
        edge_map = molecule.atom_map[molecule.edge_list[:, :2]]
        is_reaction_bond = (edge_map > 0).all(dim=-1) & \
                           (edge_map == reaction_center.unsqueeze(0)).all(dim=-1)
        atoms = is_reaction_atom.nonzero().flatten().tolist()
        bonds = is_reaction_bond[node_in < node_out].nonzero().flatten().tolist()
        return atoms, bonds

    products = batch["graph"][1]
    reaction_centers = result["reaction_center"]

    for i, product in enumerate(products):
        true_atoms, true_bonds = atoms_and_bonds(product, product.reaction_center)
        true_atoms, true_bonds = set(true_atoms), set(true_bonds)
        pred_atoms, pred_bonds = atoms_and_bonds(product, reaction_centers[i])
        pred_atoms, pred_bonds = set(pred_atoms), set(pred_bonds)
        overlap_atoms = true_atoms.intersection(pred_atoms)
        overlap_bonds = true_bonds.intersection(pred_bonds)
        atoms = true_atoms.union(pred_atoms)
        bonds = true_bonds.union(pred_bonds)

        red = (1, 0.5, 0.5)
        blue = (0.5, 0.5, 1)
        purple = (1, 0.5, 1)
        atom_colors = {}
        bond_colors = {}
        for atom in atoms:
            if atom in overlap_atoms:
                atom_colors[atom] = purple
            elif atom in pred_atoms:
                atom_colors[atom] = red
            else:
                atom_colors[atom] = blue
        for bond in bonds:
            if bond in overlap_bonds:
                bond_colors[bond] = purple
            elif bond in pred_bonds:
                bond_colors[bond] = red
            else:
                bond_colors[bond] = blue

        plot.highlight(product, atoms, bonds, atom_colors, bond_colors)

.. image:: ../../../asset/dataset/uspto50k_reaction_g2gs_valid_0.png
    :width: 24%
.. image:: ../../../asset/dataset/uspto50k_reaction_g2gs_valid_1.png
    :width: 24%
.. image:: ../../../asset/dataset/uspto50k_reaction_g2gs_valid_2.png
    :width: 24%
.. image:: ../../../asset/dataset/uspto50k_reaction_g2gs_valid_3.png
    :width: 24%

Synthon Completion
------------------

Similarly, we train a synthon completion model on the synthon dataset. For
demonstration, we only train the model for 10 epochs, while more epochs can
give better results.

.. code:: python

    synthon_model = models.RGCN(input_dim=dataset.node_feature_dim,
                                hidden_dims=[256, 256, 256],
                                num_relation=dataset.num_bond_type,
                                short_cut=True)
    synthon_task = tasks.SynthonCompletion(synthon_model, feature=("graph",))

    synthon_optimizer = torch.optim.Adam(synthon_task.parameters(), lr=1e-3)
    synthon_solver = core.Engine(synthon_task, synthon_train, synthon_valid, synthon_test, optimizer,
                                 gpus=[0], batch_size=64)
    synthon_solver.train(10)
    synthon_solver.evaluate("valid")

We may obtain some results like

.. code:: bash

    bond accuracy: 0.982559
    node in accuracy: 0.966307
    node out accuracy: 0.891787
    stop accuracy: 0.93474
    total accuracy: 0.848761

We then perform beam search to generate reactant candidates.

.. code:: python

    batch = []
    reaction_set = set()
    for sample in synthon_valid:
        if sample["reaction"] not in reaction_set:
            reaction_set.add(sample["reaction"])
            batch.append(sample)
            if len(batch) == 4:
                break
    batch = data.graph_collate(batch)
    batch = utils.cuda(batch)
    reactants, synthons = batch["graph"]
    predictions = synthon_task.predict_reactant(batch, num_beam=10, max_prediction=5)

    synthon_id = 0
    i = 0
    titles = []
    graphs = []
    for prediction in predictions:
        if synthon_id != prediction.synthon_id:
            synthon_id = prediction.synthon_id.item()
            i = 0
            graphs.append(reactants[synthon_id])
            titles.append("Truth %d" % synthon_id)
        i += 1
        graphs.append(prediction)
        if reactants[synthon_id] == prediction:
            titles.append("Prediction %d-%d, Correct!" % (synthon_id, i))
        else:
            titles.append("Prediction %d-%d" % (synthon_id, i))

    # reset attrbutes so that pack can work properly
    for i in range(len(graphs)):
        graphs[i] = data.Molecule.from_molecule(graphs[i].to_molecule())
    graphs = data.PackedMolecule.pack(graphs)
    graphs.visualize(titles, save_file="uspto50k_synthon_valid.png", num_col=6)

For each row in the visualization, the first molecule corresponds to the ground truth.
The rest molecules are candidates from beam search, ordered by their log likelihood.
We can see that our model can recall ground truth in top-5 predictions for some samples.

.. image:: ../../../asset/dataset/uspto50k_synthon_g2gs_valid.png

Retrosynthesis
--------------

Given the trained models, we can combine them into an end2end pipeline. This
is done by wrapping the two sub tasks into a retrosynthesis task.

.. code:: python

    task = tasks.Retrosynthesis(reaction_task, synthon_task)

In the case we want to load models from checkpoints, we may use the following
code.

.. code:: python

    asdfasdf

.. code:: python